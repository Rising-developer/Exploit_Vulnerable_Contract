# Vulnerable Smart Contract Demo

This project demonstrates a vulnerability in a smart contract due to incorrect use of function visibility modifiers.

## Vulnerability Explanation

The `VulnerableBank` contract has a `vulnerableWithdraw` function that's declared as `public` instead of `external`. This allows it to be called internally, which can lead to unexpected behavior in certain scenarios.

The vulnerability lies in the fact that the balance is updated before the transfer is made. In a reentrancy attack, an attacker can call this function repeatedly before the first call completes, draining more funds than they should be able to.

## Setup

(using bash)

1. Install Truffle and Ganache CLI:

npm install -g truffle ganache-cli


2. Start Ganache CLI:

ganache-cli


3. In a new terminal, compile and deploy the contracts:

truffle compile
truffle migrate


## Testing the Vulnerability

1. Open the Truffle console:

truffle console


2. Get instances of both contracts:
```
//javascript
let vulnerableBank = await VulnerableBank.deployed()
let attacker = await Attacker.deployed()
```

Check initial balances:
```
//javascript
(await web3.eth.getBalance(vulnerableBank.address)).toString()
(await web3.eth.getBalance(attacker.address)).toString()
```

Perform the attack:
```
//javascript

await attacker.attack({value: web3.utils.toWei('1', 'ether')})
```

Check balances after the attack:
```
//javascript

    (await web3.eth.getBalance(vulnerableBank.address)).toString()
    (await web3.eth.getBalance(attacker.address)).toString()
```

You should see that the attacker has withdrawn more than they deposited, demonstrating the vulnerability.
Prevention

To prevent this vulnerability:

- Use external instead of public for functions that are only called externally.
- Implement the checks-effects-interactions pattern.
- Use OpenZeppelin's ReentrancyGuard for additional protection against reentrancy attacks.


This setup demonstrates a vulnerability related to function visibility andreentrancy. The `public` modifier on `vulnerableWithdraw` allows it to becalled internally, which the attacker exploits. In a real-world scenario, always use the appropriate visibility modifiers and follow secure coding practices to prevent such vulnerabilities.


